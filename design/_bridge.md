---
description: Structural Pattern
---

# Bridge Pattern

## Intro

- 큰 클래스 또는 밀접하게 관련된 클래스 집합을 서로 독립적으로 개발할 수 있는 추상화 및 구현이라는 두 개의 개별 계층으로 분할 할 수 있는 구조적 디자인 패턴이다.

### 문제 상황

- 상속 관계의 코드에서 흔히 발생 할 수 있는 문제점은 하나의 카테고리로 구분하여 개발했지만, 추후 지속적인 확장으로 잠재적인 카테고리가 발생하는 경우
- **Bridge Pattern** 은 상속 관계를 개체 구성으로 전환하여 문제를 해결하는 방식이다.

### **추상화** 및 **구현**

- **추상화**는 높은 수준의 제어 로직을 제공하고, 저수준 작업을 수행하기 위해 **구현** 객체에 의존하게 된다.
  
- **구현**은 모든 구체적인 구현에 대한 공통 인터페이스를 선언한다.
  **추상화**는 여기에 선언된 메서드를 통해서만 구현 개체와 통신할 수 있다.

- 구체적인 **구현**에는 플랫폼 별 코드가 포함되어 있다.
  
- 세련된 추상화는 제어 로직의 변형을 제공한다.
   부모와 마찬가지로 일반 구현 인터페이스를 통해 다른 구현으로 작업한다.
  
- 일반적으로 클라이언트는 **추상화** 객체가 제공하는 인터페이스에만 관심을 갖는다.
   결국 추상화 개체를 구현 개체 중 하나와 연결하는 것은 클라이언트의 작업이다.

### 적용가능한 상황

- 일부 기능에 대해서 다양한 변형이 존재하는 **모놀리틱 클래스**를 
  확장성 있게 나누고 구성하려는 경우 **Bridge 패턴**을 사용할 수 있다.
  
- 모놀리틱 클래스가 커질수록 작동 방식을 파악하기 어려워지고 변경하는데 더 오래 걸리게 된다.
- 기능 변형 중에 하나를 변경하기 위해서 전체 클래스를 변경해야 하는 경우

- 런타임에 구현 클래스로 전환되어 실행할 수 있어야 하는 경우 Bridge 패턴을 사용한다.
	- 선택사항이지만 Bridge 패턴을 사용하면 추상화 내부의 구현 개체를 바꿀 수 있다.
	

### 구현 방법

- 클라이언트에 필요한 작업을 확인하고 **기본 추상화 클래스**에서 정의한다.
  
- **모든 플랫폼**에서 사용 가능한 작업을 결정한다.
   일반 구현 인터페이스에서 추상화에 필요한 것을 선언한다.
  
- **도메인**의 모든 플랫폼에 대해 구체적인 구현 클래스를 생성하되 모두 구현 인터페이스를 따르는지 확인
  
- 추상화 클래스 내에 구현 유형에 대한 참조 필드를 추가
   추상화는 대부분의 작업을 해당 필드에서 참조되는 구현 개체에 위임한다.
  
- 고수준 로직의 여러 변형이 있는 경우 기본 추상화 클래스를 확장하여 각 변형에 대해 정제된 추상화를 만든다.
  
- 클라이언트 코드는 구현 개체를 추상화의 생성자에 전달하여 하나를 다른 개체와 연결해야 한다.
   그 후에 클라이언트는 구현을 잊어 버리고 추상화 개체로만 작업할 수 있다.

### 장점과 단점

- 플랫폼에 독립적인 클래스와 앱을 만들 수 있다.
- 클라이언트 코드는 높은 수준의 추상화와 함께 작동한다.
  플랫폼 세부 정보에 노출되지 않는다.
- OCP 원칙: 서로 독립적으로 새로운 추상화와 구현을 도입할 수 있다.
- SRP 원칙: 추상화 고수준 논리와 구현의 플랫폼 세부 사항에 집중할 수 있다.
- High Cohesion: 클래스에 패턴을 적용하여 코드를 더욱 복잡하게 할 수 있다.


![img.png](/design/contents/img/tv_bridge.png)
