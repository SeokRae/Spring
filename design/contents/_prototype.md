# Prototype Pattern

## 프로토 타입 패턴?

- 기존 개체를 복사하여 새 개체를 만드는 작업
- 복사본이 만들어지는 객를 **프로토 타입**이라 한다.

- 프로토 타입 객체를 다른 객체가 생성되는 시드 객체로 생각할 수 있지만, 
  왜 객체의 사본을 생성해야 하는지?, 왜 새로 생성하지 않는지 질문할 수 있다.
  
### 프로토 타입 객체을 사용하는 이유?

- 새 개체를 만드는 것이 기존 개체를 복사하는 것보다 비용이 많이 든다.

- 클래스가 런타임에만 로드되고, 생성자를 정적으로 액세스 할 수 없는 경우, 런타입 환경은 동적으로 로드된 각 클래스의 인스턴스를 자동으로 생성하고 프로토 타입 관리자에 등록한다.
- 응용 프로그램은 프로토 타입 관리자로부터 객체를 요청할 수 있으며, 이 객체는 프로토 타입의 복제본을 반환할 수 있다.

-프로토 타입 인스턴스에서 복제된 개체의 값을 변경하면 시스템의 클래스 수를 크게 줄일 수 있다.

> **프로토 타입 인스턴스를 모델로 사용하여 생성 할 객체의 종류를 지정**하고 **프로토 타입을 복사하여 새 객체를 생성**하는 것으로 정의된다.


  IAircraftPrototype
        \
         \
          \
          F16 ----- Client.setEngine(new F16_A_Engine() or new F16_B_Engine())

## 얕은 복사 vs 깊은 복사

- 프로토 타입 패턴을 사용하기 위해서는 프로토 타입 클래스 또는 인터페이스가 clone() 메서드를 구현해야 한다.
  - 얕은 복사는 복제된 객체는 프로토 타입과 동일한 F16Engine 개체를 가리킨다.
    - 그러므로 엔진 객체는 결국 둘 사이에 공유된다.
  - 깊은 복사를 통해 복제된 개체는 자체 엔진 자체와 그 안에 중첩 된 개체의 복사본을 가져온다.
    - 그러므로 프로토 타입과 복제본간에 필드가 중첩된다거나 공유되지 않는다.

## 동적 로딩

- 프로토 타입 패턴은 클래스의 Dynamic Loading 에도 도움이 된다.
- 동적 로드를 허용하는 언어 프레임워크는 로드된 클래스의 인스턴스를 만들고 관리 엔티티에 등록한다.
- 응용 프로그램은 런타임에 관리자로부터 로드 된 클래스의 개체를 요청할 수 있다.
- 응용 프로그램은 클래스의 생성자에 정적으로 액세스 할 수 없다.


## Java API

- java.lang.Cloneable
- clone() 메서드는 Object 클래스에서 퍼블릭 인터페이스로 제공된다.

## 주의사항

- clone 메서드를 구현하는 것은 순환 참조로 인해 어려울 수 있다.
