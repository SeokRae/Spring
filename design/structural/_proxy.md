---
description: Structural Pattern
---

# Proxy Pattern

## Intro

- 프록시 클래스가 Wrapper의 역할을 함으로써 클라이언트에서는 프록시 클래스를 통해 간접적으로 주체 클래스를 사용하는 방식
- 클라이언트는 주체 클래스와 직접적으로 상호작용하지 못하도록 보호된다.

## 프록시를 사용하는 몇가지 상황

- 인터넷을 통해 다른 JVM 또는 다른 주소 공간에서 실행되는 원격 개체에 접근하기 위해서
- 엑세스 권한이 없는 클라이언트로부터 주체를 보호하기 위해서
- 생성하는 비용이 많이 드는 개체를 대신하여 개체에 엑세스 할 때까지 개체 생성을 지연하려는 경우
- 클라이언트에 대한 쿼리 또는 결과를 캐시하기 위해서
- 방화벽 프록시, 동기화 프록시 등과 같은 사례를 위해서

## 프록시 패턴의 방식 3 가지

- Virtual Proxy
	- 주체 클래스가 리소스 집약적인 경우
	- 프록시 클래스에서 작은 작업들을 처리하고 리소스가 많이 요구되는 작업들을 필요로할 때만 주체 클래스를 사용하도록 구현하는 방법

- Protection Proxy
	- 주체 클래스에 대한 접근을 제어하기 위한 경우
	- 프록시 클래스에서 클라이언트가 주체 클래스에 대한 접근을 허용할 지 말지 결정하도록 하는 방법

- Remote Proxy
	- 프록시 클래스는 로컬에 두고 주체 클래스는 Remote로 존재하는 경우
	- Google Docs 처럼 브라우저는 브라우저대로 필요한 자원을 로컬에 갖고 있고, 또 다른 자원은 Google 서버에 갖는 형태

## 프록시를 사용하는 예

- java.lang.reflect.Proxy
- java.rmi.*
	- 원격 메서드 호출
	- 하나의 JVM에 있는 객체가 다른 JVM(Java Virtual Machine)의 객체에 대한 메서드를 호출할 수 있도록 하는 매커니즘
	- RMI는 마샬링을 사용하여 와이어를 통해 메서드 매개 변수를 전송하고 주체는 이를 다시 객체로 마샬링한다.
