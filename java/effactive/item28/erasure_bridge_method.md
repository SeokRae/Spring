# Effects of Type Erasure and Bridge Methods

## Intro

- [참고- Effects of Type Erasure and Bridge Methods](https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html)

## Effects of Type Erasure and Bridge Methods

- 타입 삭제로 인해 예상치 못한 상황이 발생할 수 있다.
- 컴파일러가 타입 삭제 프로세스의 일부로 브릿지 메서드를 작성하는 방법

```java
public class Node<T> {

    public T data;

    public Node(T data) { this.data = data; }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

```java
class Client {
    public static void main(String[] args) {
        MyNode mn = new MyNode(5);
        Node n = mn;            // A raw type - compiler throws an unchecked warning
        n.setData("Hello");     // Causes a ClassCastException to be thrown.
        Integer x = mn.data;
    }
}
```

```java
class Client {
    public static void main(String[] args) {
        MyNode mn = new MyNode(5);
        Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning
        n.setData("Hello");          // Causes a ClassCastException to be thrown.
        Integer x = (String)mn.data;
    }
}
```

## Bridge Methods

- 매개 변수화된 클래스를 확장하거나 매개변수화된 인스턴스를 구현하는 클래스 또는 인터페이스를 컴파일 할 때 컴파일러는 타입 삭제 프로세스의 일부로 브릿지 메서드를 만들어야 할 수 있다.
- 일반적으로 브릿지 메서드에 대해 걱정할 필요는 없지만 stack trace에 나타나는 경우 당황할 수 있다.

```java
public class Node {

    public Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

- 타입 삭제 후 메서드 시그니처가 일치하지 않는다.
- Node.setData(T) 메서드는 Node.setData(Object) 가 된다.
- 결과적으로 MyNode.setData(Integer) 메서드는 Node.setData(Object) 메서드를 재정의하지 않는다.

- 이 문제를 해결하고 타입 삭제 후 일반 타입의 다형성을 보존하기 위해서 자바 컴파일러는 하위 타입이 예상대로 작동하는지 확인하는 브릿지 메서드를 생성한다.

> MyNode 클래스는 컴파일러가 setData 메서드를 브릿지 메서드로 생성한다.

```java
class MyNode extends Node {

    // Bridge method generated by the compiler
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}
```

- 브릿지 메서드 MyNode.setData(Object)는 원래 메서드 MyNode.setData(Integer)에 위임된다.
- 결과적으로 n.setData("Hello")는 MyNode.setData(Object)메서드를 호출하고 "Hello"를 Integer로 캐스팅할 수 없기 때문에 ClassCastException 예외를 발생시킨다.
